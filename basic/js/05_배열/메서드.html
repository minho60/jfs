<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>메서드</title>
</head>

<body>
    <script>

        /* 
            배열의 메서드(method)
                1) join
                2) concat
                3) reverse
                4) sort
                5) slice
                6) splice
                7) pop
                8) push
                9) shift
                10) unshift
                11) forEach
                12) map
                13) filter
                14) indexOf
                15) lastIndexOf
        */
        let result;
        const cities = ['서울', '경기', '인천'];
        // 배열이름.메서드()
        // 배열.join(): ,
        result = cities.join();
        document.write(result + '<br>');
        document.write(typeof result + '<br>');
        document.write(cities + '<br>');
        document.write(typeof cities + '<br>');
        // 베열.join('구분자')
        result = cities.join('-');
        document.write(result + '<br>');
        result = cities.join('그리고');
        document.write(result + '<br>');

        document.write(`<br>---------------------<br>`)

        const fruits = ['사과', '포도', '딸기'];
        const names = ['가렌', '아무무', '렝가'];

        // 배열.concat(값, 값,...)
        result = cities.concat('전주', '울산')
        document.write(result + '<br>');
        document.write(cities + '<br>');
        document.write(typeof result + '<br>');
        document.write(typeof cities + '<br>');
        result = cities.concat(fruits);
        document.write(result + '<br>');
        // 메서드 체이닝
        result = cities.concat(fruits).join('-');
        document.write(result + '<br>');
        result = cities.concat(fruits, names, '합체');
        document.write(result + '<br>');

        document.write(`<br>---------------------<br>`)

        const nums = [9, 8, 7, 6, 5, 4, 3, 2, 1];
        // reverse()
        result = nums.reverse();
        document.write(result + '<br>');
        result = names.join();
        document.write(result + '<br>');
        result = names.reverse();
        document.write(result + '<br>');
        document.write(typeof result + '<br>');

        document.write(`<br>---------------------<br>`)

        const ndata1 = [19, 38, 67, 26, 55, 24, 53, 12, 31];
        // 숫자의 경우 자릿수가 다른 숫자를 정렬할 때 문제 발생!
        const ndata2 = [132, 2, 41, 123, 45, 1234, 6, 29, 4567];
        const edata = ['Apple', 'Html', 'Game', 'Computer', 'Java'];
        let kdata = ['서울', '부산', '구포', '대구', '인천'];
        // sort() - 오른차순 정렬
        // 1,2,3,4,...
        // 가,나,다,라,...
        // a,b,c,d,....
        result = ndata1.sort();
        document.write(result + '<br>');
        // 함수 데이터: function(){}
        // sort(비교함수)
        // sort(function(a,b){return a-b;})
        // 화살표함수 sort((a,b)=> a-b;)
        // result = ndata2.sort( function(a,b){return a-b;} );
        result = ndata2.sort((a, b) => a - b);
        document.write(result + '<br>');
        result = edata.sort();
        document.write(result + '<br>');
        result = kdata.sort();
        document.write(typeof result + '<br>');
        document.write(result + '<br>');
        document.write(`<br>---------------------<br>`)

        kdata = ['서울', '부산', '구포', '대구', '인천', '대전', '세종'];
        // slice(인덱스1, 인덱스2) - 기존 배열은 변경되지 않는다.
        // 인덱스1에서  (인덱스2-1) 까지의 값을 새로운 배열로 반환
        result = kdata.slice(0, 4);
        document.write(result + '<br>'); // 서울,부산,구포,대구
        result = kdata.slice(-2, -1);
        document.write(result + '<br>');// 대전
        result = kdata.slice(-4, -2);
        document.write(result + '<br>');// 대구, 인천
        document.write(typeof result + '<br>');

        document.write(`<br>---------------------<br>`)

        // 배열명.splice(시작index,[삭제개수], [요소1,요고2,...])
        //splice - 기존 배열이 변경된다.
        // - 시작 인덱스 부터 삭제개수만큼 반환


        // kdata = [서울,부산,구포,대구,인천,대전,세종]


        result = kdata.slice(1, 3);
        document.write(result + '<br>');
        document.write(kdata + '<br>');

        document.write(kdata + '<br>');
        result = kdata.splice(1, 2);
        document.write(result + '<br>');
        document.write(kdata + '<br>');

        // [서울,대구,인천,대전,세종]
        result = kdata.splice(1, 1, '경기', '수지');
        document.write(result + '<br>');
        document.write(kdata + '<br>');

        // 요소 삭제 -음수 데이터
        document.write('요소삭제 음수데이터<br>');
        result = kdata.splice(-3, 2);
        document.write(result + '<br>');
        document.write(kdata + '<br>');


        // [서울,경기,수지,인천,대전,세종]
        // 2번 인덱스 부터 배열의 끝 인덱스까지 추출
        result = kdata.splice(3, Number.MAX_VALUE);
        document.write(result + '<br>');
        document.write(kdata + '<br>');

        // 모든 요소 삭제
        document.write('모든요소 삭제<br>')
        result = kdata.splice(0);
        document.write(result + '<br>');
        document.write(kdata + '<br>');

        // push & pop
        // kdata=['서울', '부산', '구포', '대구', '대전'];

        // push
        // 요소 추가 - 배열의 맨 끝에 추가
        // 스택(stack):FILD(First In Last Out) - 먼저입력된 데이터가 나중 출력된다.
        result = kdata.push('서울', '부산', '구포', '대구', '대전', '청주', '세종');
        document.write('배열개수: ' + result + '<br>');
        document.write(kdata + '<br>');

        // pop
        // 요소 삭제 -배열의 맨 끝 요소를 하나씩 삭제
        result = kdata.pop();
        document.write('제거 배열: ' + result + '<br>');
        document.write(kdata + '<br>');

        //unshift(값,값,...)
        // 요소추가- 배열 맨앞에 추가
        result = kdata.unshift('한국');
        document.write('요소 맨앞에 추가: ' + result + '<br>');
        document.write(kdata + '<br>');

        // shift()
        // 요소삭제 -배열의 맨 앞 요소를 하나씩 삭제
        result = kdata.shift();
        document.write('맨앞요소 제거: ' + result + '<br>');
        document.write(kdata + '<br>');

        //delete


        // delete 키워드로 삭제한 요소는 undefined를 반환
        delete kdata[0];
        delete kdata[1];
        delete kdata[2];
        delete kdata[3];
        delete kdata[4];
        delete kdata[5];
        delete kdata[6];
        for (let i = 0; i < kdata.length; i++) {
            document.write(`배열데이터[${i}] = ${kdata[i]} <br>`);
        }
        document.write('배열개수: ' + kdata.length + '<br>');
        document.write(kdata + '<br>');

        document.write(`<br>---------------------<br>`)
        kdata = ['서울', '청주', '부산', '대구'];

        // 일반 for
        document.write(`일반 for -----------<br>`)
        for (let i = 0; i < kdata.length; i++) {
            document.write(`배열 데이터[${i}] : ${kdata[i]} <br>`);
        }

        // for~of: index가 없다.
        // for(const 변수 of 배열){};
        document.write(`for~of -----------<br>`)
        for (const val of kdata) {
            document.write(`배열 데이터: ${val} <br>`)
        }


        // forEach(콜백함수)
        // 배열명.forEach(function(val,idx,[arr]){코드};)
        // forEach(아이템, 인덱스, 배열)
        // - 배열을 반복하며 저장된 데이터를 조회
        document.write(`forEach -----------<br>`)
        function printArr(item, index) {
            document.write(`배열 데이터[${index}] : ${item} <br>`)
        }
        kdata.forEach(printArr);
        document.write(` ----------------------------<br>`)
        //1~10까지의 합
        let sum = 0;
        let datas = [1, 2, 3, 4, 5, 3, 6, 7, 3, 8, 9, 10]
        datas.forEach(function (val) {
            sum += val;
        });
        document.write(`1~10까지의 합: ${sum} <br>`);
        
        document.write(` map()----------------------------<br>`);
        // map() -새 배열 생성
        // map(콜백함수)
        // map(function(val, idx, arr){ })
        result = datas.map(function(val){ 
            return val*val;
        })
        document.write(`기존 배열: ${datas} <br>` );
        document.write(`새 배열: ${result} <br>` );
        
        document.write(` filter()----------------------------<br>`);

         // filter() -새 배열 생성
        // filter(콜백함수)
        // 배열명.filter(function(val, idx, arr){ return 조건식; });
        result = datas.filter(function(val){ 
            return val>=6;
        })
        document.write(`기존 배열: ${datas} <br>` );
        document.write(`새 배열: ${result} <br>` );

        document.write(` indexOf()/ lastIndexOf()----------------------------<br>`);
        datas=[1,2,3,4,5,3,7,8,3,10]
        // indexOf(val, [fromidx])
        // - val에 대한 인덱스 반환, 앞에서 부터
        // - fromidx: 검색을 시작할 인덱스
        // lastIndexOf(val, [fromidx])
        // - 값에 대한 인덱스 반환, 뒤에서 부터

        //왼쪽에서 첫 번째로 찾은 3의 인덱스를 반환
        document.write( '인덱스: '+datas.indexOf(3)+'<br>'); // 인덱스: 2
        // 2번 인덱스 부터 끝방향으로 3을 찾아 인덱스를 반환
        document.write( '인덱스: '+datas.indexOf(3,3)+'<br>');
        // 끝에서 첫 번쨰로 찾은 3의 인덱스를 반환
        document.write( '인덱스: '+datas.lastIndexOf(3)+'<br>');
        // 3번째 인덱스부터 시작방향으로 3을 찾아 인덱스를 반환
        document.write( '인덱스: '+datas.lastIndexOf(3,3)+'<br>');

    </script>
</body>

</html>